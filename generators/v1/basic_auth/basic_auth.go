// /*
// Copyright Â© 2025 ESO Maintainer Team
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// */

// Copyright External Secrets Inc. All Rights Reserved

// Package basic_auth implements basic authentication generator.
package basic_auth

import (
	"context"
	"crypto/rand"
	"errors"
	"fmt"
	"math/big"
	"strings"
	"time"

	apiextensions "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/yaml"

	genv1alpha1 "github.com/external-secrets/external-secrets/apis/generators/v1alpha1"
	"github.com/external-secrets/external-secrets/generators/v1/password"
)

// Generator implements basic authentication credential generation.
type Generator struct{}

const (
	defaultUsernameLength = 8
	defaultWordCount      = 1
	defaultSeparator      = "_"
	consonants            = "bcdfghjklmnpqrstvwxyz"
	vowels                = "aeiou"

	errNoSpec    = "no config spec provided"
	errParseSpec = "unable to parse spec: %w"
	errGetToken  = "unable to get authorization token: %w"
)

type usernameGenerateFunc func(
	length int,
	prefix string,
	sufix string,
	wordCount int,
	separator string,
	includeNumbers bool,
) (string, error)

type passwordGenerateFunc func(passSpec genv1alpha1.PasswordSpec) ([]byte, error)

// Generate generates basic authentication credentials.
func (g *Generator) Generate(_ context.Context, jsonSpec *apiextensions.JSON, _ client.Client, _ string) (map[string][]byte, genv1alpha1.GeneratorProviderState, error) {
	return g.generate(
		jsonSpec,
		generateUsername,
		generatePassword,
	)
}

// Cleanup cleans up generated basic auth credentials.
func (g *Generator) Cleanup(_ context.Context, _ *apiextensions.JSON, _ genv1alpha1.GeneratorProviderState, _ client.Client, _ string) error {
	return nil
}

// GetCleanupPolicy returns the cleanup policy for this generator.
func (g *Generator) GetCleanupPolicy(_ *apiextensions.JSON) (*genv1alpha1.CleanupPolicy, error) {
	return nil, nil
}

// LastActivityTime returns the last activity time for generated resources.
func (g *Generator) LastActivityTime(_ context.Context, _ *apiextensions.JSON, _ genv1alpha1.GeneratorProviderState, _ client.Client, _ string) (time.Time, bool, error) {
	return time.Time{}, false, nil
}

// GetKeys returns the keys generated by this generator.
func (g *Generator) GetKeys() map[string]string {
	return map[string]string{
		"username": "Basic Auth username",
		"password": "Basic Auth password",
	}
}

func (g *Generator) generate(
	jsonSpec *apiextensions.JSON,
	userGen usernameGenerateFunc,
	passGen passwordGenerateFunc,
) (map[string][]byte, genv1alpha1.GeneratorProviderState, error) {
	if jsonSpec == nil {
		return nil, nil, errors.New(errNoSpec)
	}
	res, err := parseSpec(jsonSpec.Raw)
	if err != nil {
		return nil, nil, fmt.Errorf(errParseSpec, err)
	}

	usernameSpec := res.Spec.Username

	usernameLen := defaultUsernameLength
	if usernameSpec.Length > 0 {
		usernameLen = usernameSpec.Length
	}
	usernamePrefix := ""
	if usernameSpec.Prefix != nil {
		usernamePrefix = *usernameSpec.Prefix
	}
	usernameSufix := ""
	if usernameSpec.Sufix != nil {
		usernameSufix = *usernameSpec.Sufix
	}
	usernameWordCount := defaultWordCount
	if usernameSpec.WordCount > 0 {
		usernameWordCount = usernameSpec.WordCount
	}
	usernameSeparator := defaultSeparator
	if usernameSpec.Separator != nil {
		usernameSeparator = *usernameSpec.Separator
	}

	user, err := userGen(
		usernameLen,
		usernamePrefix,
		usernameSufix,
		usernameWordCount,
		usernameSeparator,
		usernameSpec.IncludeNumbers,
	)
	if err != nil {
		return nil, nil, err
	}

	pass, err := passGen(res.Spec.Password)
	if err != nil {
		return nil, nil, err
	}

	return map[string][]byte{
		"username": []byte(user),
		"password": pass,
	}, nil, nil
}

func generateUsername(
	userLen int,
	prefix string,
	sufix string,
	wordCount int,
	separator string,
	includeNumbers bool,
) (string, error) {
	if wordCount <= 0 || userLen <= 0 {
		return "", fmt.Errorf("invalid wordCount=%d or len=%d", wordCount, userLen)
	}

	generatedUsername := ""
	for i := 0; i < wordCount; i++ {
		// Generate a fake word
		fakeWord := generateFakeWord(userLen)
		// Capitalize the first letter
		fakeWord = strings.ToLower(fakeWord)

		// Append the separator if it's not the first word
		if i != 0 {
			generatedUsername += separator
		}

		// Append the fake word
		generatedUsername += fakeWord
	}

	generatedUsername = prefix + generatedUsername + sufix

	if includeNumbers {
		for i := 0; i < 4; i++ {
			ioReader := rand.Reader
			randomNumber, err := rand.Int(ioReader, new(big.Int).SetInt64(9))
			if err != nil {
				return "", err
			}
			generatedUsername += fmt.Sprintf("%d", randomNumber)
		}
	}
	return generatedUsername, nil
}

func generatePassword(
	passSpec genv1alpha1.PasswordSpec,
) ([]byte, error) {
	gen := password.Generator{}
	rawPassSpec, err := yaml.Marshal(passSpec)
	if err != nil {
		return nil, err
	}
	passMap, _, err := gen.Generate(context.TODO(), &apiextensions.JSON{Raw: rawPassSpec}, nil, "")

	if err != nil {
		return nil, err
	}

	pass, ok := passMap["password"]
	if !ok {
		return nil, errors.New("password not found in generated map")
	}
	return pass, nil
}

func generateFakeWord(size int) string {
	word := []byte{}
	ioReader := rand.Reader
	for i := 0; i < size/2; i++ {
		randomNumber, err := rand.Int(ioReader, big.NewInt(int64(len(consonants))))
		if err != nil {
			randomNumber = big.NewInt(0)
		}
		word = append(word, consonants[int(randomNumber.Int64())])
		randomNumber, err = rand.Int(ioReader, big.NewInt(int64(len(vowels))))
		if err != nil {
			randomNumber = big.NewInt(0)
		}
		word = append(word, vowels[int(randomNumber.Int64())])
	}

	if size%2 != 0 {
		randomNumber, err := rand.Int(ioReader, big.NewInt(int64(len(consonants))))
		if err != nil {
			randomNumber = big.NewInt(0)
		}
		word = append(word, consonants[int(randomNumber.Int64())])
	}

	return string(word)
}

func parseSpec(data []byte) (*genv1alpha1.BasicAuth, error) {
	var spec genv1alpha1.BasicAuth
	err := yaml.Unmarshal(data, &spec)
	return &spec, err
}

// NewGenerator creates a new Generator instance.
func NewGenerator() genv1alpha1.Generator {
	return &Generator{}
}

// Kind returns the generator kind.
func Kind() string {
	return genv1alpha1.BasicAuthKind
}
