/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by providers/v2/hack/generate-provider-main.go. DO NOT EDIT.

package main

import (
	"context"
	"flag"
	"fmt"
	"log"
	"net"
	"os"
	"os/signal"
	"syscall"

	"google.golang.org/grpc/health"
	"google.golang.org/grpc/health/grpc_health_v1"
	"google.golang.org/grpc/reflection"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	clientgoscheme "k8s.io/client-go/kubernetes/scheme"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/client/config"

	{{- if .HasStores}}
	v1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1"
	{{- end}}
	{{- if .HasGenerators}}
	genv1alpha1 "github.com/external-secrets/external-secrets/apis/generators/v1alpha1"
	{{- end}}
	{{- if .Provider.Provider.V2Package}}
	{{.Provider.Provider.Name}}v2alpha1 "{{.Provider.Provider.V2Package}}"
	{{- end}}
	{{- if .HasGenerators}}
	genpb "github.com/external-secrets/external-secrets/proto/generator"
	{{- end}}
	{{- if .HasStores}}
	pb "github.com/external-secrets/external-secrets/proto/provider"
	{{- end}}
	{{- if and .HasStores .HasGenerators}}
	"github.com/external-secrets/external-secrets/providers/v2/adapter"
	{{- end}}
	{{- if .HasGenerators}}
	adaptergenerator "github.com/external-secrets/external-secrets/providers/v2/adapter/generator"
	{{- end}}
	{{- if .HasStores}}
	adapterstore "github.com/external-secrets/external-secrets/providers/v2/adapter/store"
	{{- end}}
	grpcserver "github.com/external-secrets/external-secrets/providers/v2/common/grpc/server"
	{{- range .UniqueStoreImports}}
	{{.Alias}} "{{.Path}}"
	{{- end}}
	{{- range .UniqueGeneratorImports}}
	{{.Alias}} "{{.Path}}"
	{{- end}}
)

var (
	port      = flag.Int("port", 8080, "The server port")
	enableTLS = flag.Bool("enable-tls", true, "Enable TLS/mTLS for gRPC server")
	verbose   = flag.Bool("verbose", false, "Enable verbose connection-level debugging")
)

func main() {
	flag.Parse()

	log.Printf("starting on port %d (TLS: %v, Verbose: %v)", *port, *enableTLS, *verbose)

	// Create Kubernetes client (required by adapter)
	scheme := runtime.NewScheme()
	_ = clientgoscheme.AddToScheme(scheme)
	{{- if .Provider.Provider.V2Package}}
	_ = {{.Provider.Provider.Name}}v2alpha1.AddToScheme(scheme)
	{{- end}}
	{{- if .HasGenerators}}
	_ = genv1alpha1.AddToScheme(scheme)
	{{- end}}

	cfg, err := config.GetConfig()
	if err != nil {
		log.Fatalf("Failed to get kubeconfig: %v", err)
	}

	kubeClient, err := client.New(cfg, client.Options{Scheme: scheme})
	if err != nil {
		log.Fatalf("Failed to create Kubernetes client: %v", err)
	}

	{{- if .HasStores}}
	// Setup v1 provider(s)
	{{- range $idx, $store := .Stores}}
	v1Provider{{$idx}} := {{$store.ImportAlias}}.{{$store.V1ProviderFunc}}()
	{{- end}}
	providerMapping := adapterstore.ProviderMapping{
		{{- range $idx, $store := .Stores}}
		schema.GroupVersionKind{
			Group:   "{{$store.GVK.Group}}",
			Version: "{{$store.GVK.Version}}",
			Kind:    "{{$store.GVK.Kind}}",
		}: v1Provider{{$idx}},
		{{- end}}
	}

	specMapper := GetSpecMapper(kubeClient)
	{{- end}}

	{{- if .HasGenerators}}
	// Setup v1 generator(s)
	generatorMapping := adaptergenerator.GeneratorMapping{
		{{- range $idx, $gen := .Generators}}
		schema.GroupVersionKind{
			Group:   "{{$gen.GVK.Group}}",
			Version: "{{$gen.GVK.Version}}",
			Kind:    "{{$gen.GVK.Kind}}",
		}: {{$gen.ImportAlias}}.{{$gen.V1GeneratorFunc}}(),
		{{- end}}
	}
	{{- end}}

	{{- if and .HasStores .HasGenerators}}
	adapterServer := adapter.NewServer(kubeClient, scheme, providerMapping, specMapper, generatorMapping)
	{{- else if .HasStores}}
	adapterServer := adapterstore.NewServer(kubeClient, providerMapping, specMapper)
	{{- else if .HasGenerators}}
	adapterServer := adaptergenerator.NewServer(kubeClient, scheme, generatorMapping)
	{{- end}}

	log.Printf("[PROVIDER] Using v1 {{.Provider.Provider.DisplayName}} provider{{if .HasGenerators}} with generators{{end}} wrapped with v2 adapter")
	grpcServer, err := grpcserver.NewGRPCServer(grpcserver.ServerOptions{
		EnableTLS: *enableTLS,
		Verbose:   *verbose,
	})
	if err != nil {
		log.Fatalf("Failed to create gRPC server: %v", err)
	}

	// Register services
	{{- if .HasStores}}
	pb.RegisterSecretStoreProviderServer(grpcServer, adapterServer)
	{{- end}}
	{{- if .HasGenerators}}
	genpb.RegisterGeneratorProviderServer(grpcServer, adapterServer)
	{{- end}}

	// Register health service
	healthServer := health.NewServer()
	grpc_health_v1.RegisterHealthServer(grpcServer, healthServer)
	healthServer.SetServingStatus("", grpc_health_v1.HealthCheckResponse_SERVING)

	// Register reflection service for debugging
	reflection.Register(grpcServer)

	// Start listening
	lis, err := net.Listen("tcp", fmt.Sprintf(":%d", *port))
	if err != nil {
		log.Fatalf("Failed to listen: %v", err)
	}

	// Handle graceful shutdown
	go func() {
		sigChan := make(chan os.Signal, 1)
		signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
		sig := <-sigChan
		log.Printf("Received signal: %v, shutting down gracefully...", sig)
		grpcServer.GracefulStop()
	}()

	// Start serving
	log.Printf("{{.Provider.Provider.DisplayName}} Provider listening on %s", lis.Addr().String())
	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("Failed to serve: %v", err)
	}
}

