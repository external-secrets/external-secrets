/*
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package common

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"sync"
	"time"

	"github.com/go-logr/logr"
	"github.com/yandex-cloud/go-sdk/iamkey"
	kclient "sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"

	esv1 "github.com/external-secrets/external-secrets/apis/externalsecrets/v1"
	esmeta "github.com/external-secrets/external-secrets/apis/meta/v1"
	clock2 "github.com/external-secrets/external-secrets/pkg/provider/yandex/common/clock"
	"github.com/external-secrets/external-secrets/pkg/utils/resolvers"

	"io"
	"net/http"
	"net/url"
	"strings"

	authenticationv1 "k8s.io/api/authentication/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	typedcorev1 "k8s.io/client-go/kubernetes/typed/core/v1"
	ctrlcfg "sigs.k8s.io/controller-runtime/pkg/client/config"
)

const maxSecretsClientLifetime = 5 * time.Minute // supposed SecretsClient lifetime is quite short

// https://github.com/external-secrets/external-secrets/issues/644
var _ esv1.Provider = &YandexCloudProvider{}

// Implementation of v1beta1.Provider.
type YandexCloudProvider struct {
	logger              logr.Logger
	clock               clock2.Clock
	adaptInputFunc      AdaptInputFunc
	newSecretGetterFunc NewSecretGetterFunc
	newIamTokenFunc     NewIamTokenFunc

	secretGetteMap       map[string]SecretGetter // apiEndpoint -> SecretGetter
	secretGetterMapMutex sync.Mutex
	iamTokenMap          map[iamTokenKey]*IamToken
	wlifTokenMap         map[wlifTokenKey]*IamToken
	iamTokenMapMutex     sync.Mutex
	corev1               typedcorev1.CoreV1Interface
}

type iamTokenKey struct {
	authorizedKeyID  string
	serviceAccountID string
	privateKeyHash   string
}

type wlifTokenKey struct {
	yandexIamServiceAccountID string
	serviceAccountName        string
	namespace                 string
	audiences                 string
}

type WlifAuthConfig struct {
	YandexIamServiceAccountID string
	ServiceAccountName        string
	Namespace                 *string
	Audiences                 []string
}

func InitYandexCloudProvider(
	logger logr.Logger,
	clock clock2.Clock,
	adaptInputFunc AdaptInputFunc,
	newSecretGetterFunc NewSecretGetterFunc,
	newIamTokenFunc NewIamTokenFunc,
	iamTokenCleanupDelay time.Duration,
) *YandexCloudProvider {

	config, err := ctrlcfg.GetConfig()
	if err != nil {
		logger.Error(err, "failed to get any Kubernetes config, token logging will be disabled")
	}

	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		logger.Error(err, err.Error())
	}

	provider := &YandexCloudProvider{
		logger:              logger,
		clock:               clock,
		adaptInputFunc:      adaptInputFunc,
		newSecretGetterFunc: newSecretGetterFunc,
		newIamTokenFunc:     newIamTokenFunc,
		secretGetteMap:      make(map[string]SecretGetter),
		iamTokenMap:         make(map[iamTokenKey]*IamToken),
		wlifTokenMap:        make(map[wlifTokenKey]*IamToken),
		corev1:              clientset.CoreV1(),
	}

	if iamTokenCleanupDelay > 0 {
		go func() {
			for {
				time.Sleep(iamTokenCleanupDelay)
				provider.CleanUpIamTokenMap()
			}
		}()
	}

	return provider
}

type NewSecretSetterFunc func()
type AdaptInputFunc func(store esv1.GenericStore) (*SecretsClientInput, error)
type NewSecretGetterFunc func(ctx context.Context, apiEndpoint string, authorizedKey *iamkey.Key, caCertificate []byte) (SecretGetter, error)
type NewIamTokenFunc func(ctx context.Context, apiEndpoint string, authorizedKey *iamkey.Key, caCertificate []byte) (*IamToken, error)

type IamToken struct {
	Token     string
	ExpiresAt time.Time
}

type SecretsClientInput struct {
	APIEndpoint               string
	AuthorizedKey             *esmeta.SecretKeySelector
	YandexIamServiceAccountID string
	ServiceAccountRef         *esmeta.ServiceAccountSelector
	CACertificate             *esmeta.SecretKeySelector
	ResourceKeyType           ResourceKeyType
	FolderID                  string
}

type ResourceKeyType int

const (
	ResourceKeyTypeId   ResourceKeyType = iota
	ResourceKeyTypeName ResourceKeyType = iota
)

func (p *YandexCloudProvider) Capabilities() esv1.SecretStoreCapabilities {
	return esv1.SecretStoreReadOnly
}

// NewClient constructs a Yandex.Cloud Provider.
func (p *YandexCloudProvider) NewClient(ctx context.Context, store esv1.GenericStore, kube kclient.Client, namespace string) (esv1.SecretsClient, error) {
	input, err := p.adaptInputFunc(store)
	if err != nil {
		return nil, err
	}

	var authorizedKey *iamkey.Key
	if input.AuthorizedKey != nil {
		key, err := resolvers.SecretKeyRef(
			ctx,
			kube,
			store.GetKind(),
			namespace,
			input.AuthorizedKey,
		)
		if err != nil {
			return nil, err
		}

		authorizedKey = &iamkey.Key{}
		err = json.Unmarshal([]byte(key), authorizedKey)
		if err != nil {
			return nil, fmt.Errorf("unable to unmarshal authorized key: %w", err)
		}
	}

	var wlifAuthConfig *WlifAuthConfig
	if input.YandexIamServiceAccountID != "" && input.ServiceAccountRef != nil {
		wlifAuthConfig = &WlifAuthConfig{
			YandexIamServiceAccountID: input.YandexIamServiceAccountID,
			ServiceAccountName:        input.ServiceAccountRef.Name,
			Namespace:                 input.ServiceAccountRef.Namespace,
			Audiences:                 input.ServiceAccountRef.Audiences,
		}
	}

	var caCertificateData []byte
	if input.CACertificate != nil {
		caCert, err := resolvers.SecretKeyRef(
			ctx,
			kube,
			store.GetKind(),
			namespace,
			input.CACertificate,
		)
		if err != nil {
			return nil, err
		}
		caCertificateData = []byte(caCert)
	}

	secretGetter, err := p.getOrCreateSecretGetter(ctx, input.APIEndpoint, authorizedKey, caCertificateData)
	if err != nil {
		return nil, fmt.Errorf("failed to create Yandex.Cloud client: %w", err)
	}

	iamToken, err := p.getOrCreateIamToken(ctx, input.APIEndpoint, authorizedKey, wlifAuthConfig, caCertificateData)
	if err != nil {
		return nil, fmt.Errorf("failed to create IAM token: %w", err)
	}

	return &yandexCloudSecretsClient{secretGetter, nil, iamToken.Token, input.ResourceKeyType, input.FolderID}, nil
}

func (p *YandexCloudProvider) getOrCreateSecretGetter(ctx context.Context, apiEndpoint string, authorizedKey *iamkey.Key, caCertificate []byte) (SecretGetter, error) {
	p.secretGetterMapMutex.Lock()
	defer p.secretGetterMapMutex.Unlock()

	if _, ok := p.secretGetteMap[apiEndpoint]; !ok {
		p.logger.Info("creating SecretGetter", "apiEndpoint", apiEndpoint)
		secretGetter, err := p.newSecretGetterFunc(ctx, apiEndpoint, authorizedKey, caCertificate)
		if err != nil {
			return nil, err
		}
		p.secretGetteMap[apiEndpoint] = secretGetter
	}
	return p.secretGetteMap[apiEndpoint], nil
}

func (p *YandexCloudProvider) getOrCreateIamToken(ctx context.Context, apiEndpoint string, authorizedKey *iamkey.Key, wlifAuthConfig *WlifAuthConfig, caCertificate []byte) (*IamToken, error) {
	p.iamTokenMapMutex.Lock()
	defer p.iamTokenMapMutex.Unlock()

	if wlifAuthConfig != nil {
		wlifTokenKey := buildWlifTokenKey(wlifAuthConfig)
		if iamToken, ok := p.wlifTokenMap[wlifTokenKey]; !ok || !p.isIamTokenUsable(iamToken) {
			iamToken2, err := p.getExchangedIamToken(ctx, wlifAuthConfig)
			if err != nil {
				p.logger.Error(err, "failed to create IAM token via exchange")
			} else {
				p.logger.Info("created IAM token via exchange", "expiresAt", iamToken2.ExpiresAt)
			}
			p.wlifTokenMap[wlifTokenKey] = iamToken2
		}
		return p.wlifTokenMap[wlifTokenKey], nil
	}

	iamTokenKey := buildIamTokenKey(authorizedKey)
	if iamToken, ok := p.iamTokenMap[iamTokenKey]; !ok || !p.isIamTokenUsable(iamToken) {
		if authorizedKey != nil {
			p.logger.Info("creating IAM token", "authorizedKeyId", authorizedKey.Id)
		} else {
			p.logger.Info("creating instance SA IAM token")
		}

		iamToken, err := p.newIamTokenFunc(ctx, apiEndpoint, authorizedKey, caCertificate)
		if err != nil {
			return nil, err
		}

		if authorizedKey != nil {
			p.logger.Info("created IAM token", "authorizedKeyId", authorizedKey.Id, "expiresAt", iamToken.ExpiresAt)
		} else {
			p.logger.Info("created instance SA IAM token", "expiresAt", iamToken.ExpiresAt)
		}

		p.iamTokenMap[iamTokenKey] = iamToken
	}
	return p.iamTokenMap[iamTokenKey], nil
}

func (p *YandexCloudProvider) isIamTokenUsable(iamToken *IamToken) bool {
	now := p.clock.CurrentTime()
	return now.Add(maxSecretsClientLifetime).Before(iamToken.ExpiresAt)
}

func buildIamTokenKey(authorizedKey *iamkey.Key) iamTokenKey {
	if authorizedKey == nil {
		return iamTokenKey{}
	}

	privateKeyHash := sha256.Sum256([]byte(authorizedKey.PrivateKey))
	return iamTokenKey{
		authorizedKey.GetId(),
		authorizedKey.GetServiceAccountId(),
		hex.EncodeToString(privateKeyHash[:]),
	}
}

func buildWlifTokenKey(wlifAuthConfig *WlifAuthConfig) wlifTokenKey {
	if wlifAuthConfig == nil {
		return wlifTokenKey{}
	}

	return wlifTokenKey{
		wlifAuthConfig.YandexIamServiceAccountID,
		wlifAuthConfig.ServiceAccountName,
		*wlifAuthConfig.Namespace,
		strings.Join(wlifAuthConfig.Audiences, " "),
	}
}

// Used for testing.
func (p *YandexCloudProvider) IsIamTokenCached(authorizedKey *iamkey.Key) bool {
	p.iamTokenMapMutex.Lock()
	defer p.iamTokenMapMutex.Unlock()

	_, ok := p.iamTokenMap[buildIamTokenKey(authorizedKey)]
	return ok
}

func (p *YandexCloudProvider) CleanUpIamTokenMap() {
	p.iamTokenMapMutex.Lock()
	defer p.iamTokenMapMutex.Unlock()

	for key, value := range p.iamTokenMap {
		if p.clock.CurrentTime().After(value.ExpiresAt) {
			p.logger.Info("deleting IAM token", "authorizedKeyId", key.authorizedKeyID)
			delete(p.iamTokenMap, key)
		}
	}
}

func (p *YandexCloudProvider) ValidateStore(store esv1.GenericStore) (admission.Warnings, error) {
	_, err := p.adaptInputFunc(store) // adaptInputFunc validates the input store
	if err != nil {
		return nil, err
	}
	return nil, nil
}

// creates token for k8s service account
func (p *YandexCloudProvider) createTokenForServiceAccount(ctx context.Context, wlifConfig *WlifAuthConfig) (string, error) {

	tokenRequest := &authenticationv1.TokenRequest{
		Spec: authenticationv1.TokenRequestSpec{
			Audiences: wlifConfig.Audiences,
		},
	}

	tokenResponse, err := p.corev1.ServiceAccounts(*wlifConfig.Namespace).
		CreateToken(ctx, wlifConfig.ServiceAccountName, tokenRequest, metav1.CreateOptions{})
	if err != nil {
		return "", err
	}

	return tokenResponse.Status.Token, nil
}

const (
	TokenUrl        = "https://auth.yandex.cloud/oauth/token"
	GrantType       = "urn:ietf:params:oauth:grant-type:token-exchange"
	IdTokenType     = "urn:ietf:params:oauth:token-type:id_token"
	AccessTokenType = "urn:ietf:params:oauth:token-type:access_token"
)

type YandexTokenResponse struct {
	AccessToken string `json:"access_token"`
	TokenType   string `json:"token_type"`
	ExpiresIn   int    `json:"expires_in"`
	Scope       string `json:"scope"`
}

func (p *YandexCloudProvider) exchangeK8sTokenForYandexIAM(ctx context.Context, k8sToken string, cloudServiceAccountID string) (*YandexTokenResponse, error) {
	formData := map[string]string{
		"grant_type":           GrantType,
		"subject_token":        k8sToken,
		"subject_token_type":   IdTokenType,
		"requested_token_type": AccessTokenType,
		"audience":             cloudServiceAccountID,
	}

	values := url.Values{}
	for key, value := range formData {
		values.Add(key, value)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", TokenUrl, strings.NewReader(values.Encode()))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	client := &http.Client{Timeout: 30 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("token exchange failed with status %d: %s", resp.StatusCode, string(body))
	}

	var tokenResp YandexTokenResponse
	if err := json.NewDecoder(resp.Body).Decode(&tokenResp); err != nil {
		return nil, fmt.Errorf("failed to decode token response: %w", err)
	}

	p.logger.Info("Successfully exchanged K8S token for Yandex IAM token",
		"cloudSA", cloudServiceAccountID,
		"expiresIn", tokenResp.ExpiresIn)

	return &tokenResp, nil
}

func (p *YandexCloudProvider) getExchangedIamToken(ctx context.Context, wlifAuthConfig *WlifAuthConfig) (*IamToken, error) {
	k8sToken, err := p.createTokenForServiceAccount(ctx, wlifAuthConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to get K8S token: %w", err)
	}

	yandexTokenResponse, err := p.exchangeK8sTokenForYandexIAM(ctx, k8sToken, wlifAuthConfig.YandexIamServiceAccountID)
	if err != nil {
		return nil, fmt.Errorf("failed to exchange token: %w", err)
	}

	expiresAt := p.clock.CurrentTime().Add(time.Duration(yandexTokenResponse.ExpiresIn) * time.Second)

	return &IamToken{
		Token:     yandexTokenResponse.AccessToken,
		ExpiresAt: expiresAt,
	}, nil
}
